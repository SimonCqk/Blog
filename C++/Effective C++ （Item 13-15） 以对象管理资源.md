> 在以前的C++用法中，`new`是非常常见的用来动态分配内存的方式，但是有`new`必须有`delete`，将内存还给系统，否则就会造成内存泄露，这是很危险的一件事情，而**以对象管理资源**这一思想就能比较好的解决这一问题

通常情况下，对于一个对象，如果是`built-in`类型，我们就直接`new`了，如果是自定义类型，一般使用工厂函数返回其指针，生成对象之后肯定需要释放对象吧，对于内置类型，就是成对的使用`delete`，但是程序复杂之后，这其实是很难做到的，对于自定义类型，一般的做法就是另定义一个函数，在这个"释放者函数"内`delete`相关资源，但是也很容易产生问题——如果在`delete`之前，函数就`return`了呢？或者就`continue`了呢？还是会内存泄漏。

**把资源放进对象**就可以很好的避免这个问题，封装入对象，在对象层面对其进行操作，则在资源需要释放的时候，就会自动调用析构函数，而不需要我们如履薄冰一般的手动`delete`了，这里还提到一种叫做`RAII(Resource Acquisition is Initialization)`的原则，即获得这个对象时立刻将其置入管理资源的类中。

C++11以前有一个`auto_ptr`指针，但是已经被弃用了所以不推荐，如果只打算一个指针管理一个对象，那么使用`unique_ptr`就行了，否则用	`shared_ptr`，要时刻注意的是，智能指针虽叫智能指针，其实质是一个模板类，如果要用智能指针重写之前的以指针传递的函数，则要使用`.get()`成员函数获得原始指针。
```cpp
class Before{
...
private:
	type* item;
}
...
lock(type* item);

...
//用shared_ptr重写
class Before{
...
private:
	std::shared_ptr<type> item;
}
...
lock(type* item.get())
```
注意`unique_ptr`指针不能传递对象，即不能复制。

因此引出——**在资源管理类中小心coping**行为

如果是复制对于设计者来说是个敏感操作，那么首先可以考虑禁用复制构造函数/赋值操作符，使用之前说过的`=delete`方法，如果确实复制操作，则可以考虑使用`shared_ptr`的引用计数，只是要注意智能指针当引用计数为0的时候，调用删除器，对象是被销毁的，如果不希望对象是被销毁的操作，那么需要我们自行传递一个`deleter`，覆盖默认的删除器，可以参考另一篇博客，只是强调：
①：`shared_ptr`的传递删除器(deleter)方式比较简单, 只需要在参数中添加具体的删除器函数名, 即可; 注意是单参数函数;
②：`unique_ptr`的删除器是函数模板`(function template)`, 所以需要在模板类型传递删除器的类型（即函数指针`(function pointer)`）, 再在参数中添加具体删除器，博客：
[智能指针自定义删除器](http://blog.csdn.net/caroline_wendy/article/details/16938707)

还有不能忽略的是，管理资源的类拷贝时，往往要复制最底层的资源，所以应该是`深拷贝`！！！！！！

在实际使用的过程中，虽然使用资源管理类封装了我们的对象，但是还是免不了要访问其原始资源，这就需要我们的资源管理类提供对原始资源的访问了。

就像前面说的，`shared_ptr`有一个`get()`成员函数，可以返回被管理对象的原始指针，除此之外，`shared_ptr`和`unique_ptr`都重载了`->`和`*`操作符，我们可以向使用普通的指针一样的操作被管理类而不用改变编码习惯，这也是标准库中这样的智能指针被称之为**指针**的原因吧，毕竟它们的使用非常接近传统的指针。
```cpp
//最好使用make_shared函数初始化智能指针
std::shared_ptr<Type> i=std::make_shared<Type>(createInstance);
//可以像这样使用
...
i->memFunc();
...
(*i).getItem();
```
所以当我们设计自己的资源管理类而不是使用标准库版本的时候，我们也可以采用类似的做法，比如设计一个`get()`接口函数，返回我们的原始资源，当然如果你想要更省力的话，可以使用隐式转换函数，但是为了避免隐式转换的滥用，还是建议使用设计`get()`函数，显式转换更安全。

最后需要注意的是，同时也是OOP编程的原则之一——不要破坏封装性，不需要/不希望提供给类使用者的细节都应该隐藏起来，在这里需要访问/获得原始数据的部分，则通过接口函数提供给使用者。
